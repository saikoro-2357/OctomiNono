<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OctomiNono</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;500;700&display=swap" rel="stylesheet">

    <style>
        /* å…¨è¦ç´ ã®ãƒœãƒƒã‚¯ã‚¹ã‚µã‚¤ã‚ºè¨ˆç®—ã‚’çµ±ä¸€ */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #102027;
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 300;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* UIãƒ¬ã‚¤ãƒ¤ãƒ¼ */
        #ui-layer {
            position: absolute;
            top: 25px;
            left: 25px;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 15px;
        }

        /* --- å·¦ä¸Š ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼ --- */
        #hamburger-btn {
            position: absolute;
            top: 25px;
            left: 25px;
            width: 50px;
            height: 50px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: background 0.2s;
        }
        #hamburger-btn:hover { background: rgba(55, 71, 79, 0.5); }

        /* ã‚µã‚¤ãƒ‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼æœ¬ä½“ */
        #side-menu {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 320px;
            background: rgba(16, 32, 39, 0.98);
            border-right: 1px solid #455a64;
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 90;
            padding: 90px 40px 40px 40px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
        }
        #side-menu.active {
            transform: translateX(0);
        }

        /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼å†…ã‚¿ã‚¤ãƒˆãƒ« */
        #menu-title {
            font-size: 24px;
            font-weight: 300;
            color: #ffffff;
            margin: 0 0 10px 0;
            border-bottom: 1px solid #00ACC1;
            padding-bottom: 15px;
            letter-spacing: 0.05em;
            white-space: nowrap;
        }

        /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³å…±é€š */
        .menu-item-btn {
            background: transparent;
            color: #eceff1;
            border: 1px solid #546E7A;
            padding: 12px 15px;
            text-align: left;
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 16px;
            font-weight: 300;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .menu-item-btn:hover {
            background: rgba(0, 172, 193, 0.15);
            border-color: #00ACC1;
            padding-left: 20px;
        }
        .menu-item-btn span { font-size: 18px; width: 24px; text-align: center; }

        /* --- å³ä¸Š æ™‚è¨ˆ --- */
        #clock-display {
            position: absolute;
            top: 25px;
            right: 25px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 64px;
            font-weight: 500;
            font-family: 'Noto Sans JP', sans-serif;
            letter-spacing: 0.02em;
            pointer-events: none;
            z-index: 10;
            text-shadow: none;
            line-height: 1;
        }

        /* --- å³ä¸‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ç¾¤ --- */
        #bottom-right-actions {
            position: absolute;
            bottom: 25px;
            right: 25px;
            display: flex;
            flex-direction: column-reverse; 
            gap: 15px;
            align-items: flex-end;
            pointer-events: none; 
            z-index: 20;
        }

        /* ä¸¸ã„ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        .action-circle-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 500;
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: transform 0.1s, background 0.2s;
            position: relative;
        }
        .action-circle-btn:active { transform: scale(0.95); }
        .action-circle-btn:hover { transform: scale(1.05); }

        #monomino-btn {
            background: #546E7A;
            color: #fff;
            font-size: 11px;
        }
        #monomino-btn span.icon { font-size: 16px; margin-bottom: 4px; }
        #monomino-btn:hover:not(:disabled) { background: #546E7A; }
        #monomino-btn:disabled {
            background: #102027;
            color: #263238;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .stock-badge {
            position: absolute;
            top: -6px;
            right: -5px;
            left: auto;
            background: #263238;
            color: #fff;
            border: 2px solid #546E7A;
            border-radius: 50%;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        #zukan-btn {
            background: #00ACC1;
            font-size: 13px;
        }
        #zukan-btn span { font-size: 20px; margin-bottom: 2px; }
        #zukan-btn:hover { background: #00BCD4; }

        /* ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ */
        #toast {
            position: absolute;
            top: 40px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 172, 193, 0.95); 
            color: #fff;
            padding: 15px 40px;
            border-radius: 4px;
            font-size: 24px; 
            font-weight: 500;
            font-family: 'Noto Sans JP', sans-serif;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
            letter-spacing: 0.05em;
            min-width: 500px;
            text-align: center;
        }
        #toast.show { opacity: 1; transform: translateX(-50%) translateY(10px); }
        
        /* æ—¢å‡º (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ/ã‚°ãƒ¬ãƒ¼) */
        #toast.existing { background: rgba(69, 90, 100, 0.95); font-size: 18px; }
        
        /* ã‚ªã‚¯ãƒˆãƒŸãƒæ–°ç¨® (æ°´è‰²) */
        #toast.new-octo { background: rgba(0, 172, 193, 0.95); font-size: 24px; }
        
        /* ãƒãƒãƒŸãƒæ–°ç¨® (ãƒ”ãƒ³ã‚¯) */
        #toast.new-nono { background: #a743e0; font-size: 24px; }
        
        #toast.alert { background: #E53935; font-size: 20px; }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(16, 32, 39, 0.95);
            display: none;
            z-index: 110; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .modal-overlay.active { display: flex; }
        
        /* å›³é‘‘ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .zukan-content {
            background: #263238;
            width: 95%;
            max-width: 1200px;
            height: 90%;
            border-radius: 4px;
            border: 1px solid #455a64;
            display: flex;
            flex-direction: column;
            padding: 20px 20px 0 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .zukan-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            color: #fff;
            padding-bottom: 5px;
            flex-shrink: 0;
        }
        .zukan-header h2 {
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 700;
            letter-spacing: 0.05em;
            margin: 0;
        }
        
        /* ã‚«ãƒ†ã‚´ãƒªèª¬æ˜ã‚¨ãƒªã‚¢ */
        #category-description {
            color: #90A4AE;
            font-size: 14px;
            margin: 0 0 10px 0;
            padding-left: 10px;
            font-family: 'Noto Sans JP', sans-serif;
            border-left: 4px solid #00ACC1; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ */
            line-height: 1.2;
            transition: border-color 0.3s;
        }

        /* ã‚¿ãƒ–ã‚¨ãƒªã‚¢ */
        .zukan-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 0; 
            padding-left: 0;
            position: relative;
            top: 1px; 
            z-index: 5;
            width: 100%;
            justify-content: flex-start;
        }
        .tab-btn {
            background: #37474F;
            color: #90A4AE;
            border: 1px solid #455A64;
            border-bottom: none;
            padding: 8px 0;
            border-radius: 6px 6px 0 0; 
            cursor: pointer;
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 300;
            font-size: 12px;
            transition: all 0.2s;
            position: relative;
            text-align: center;
            width: 50px; 
            flex: 0 0 auto;
        }
        .tab-btn:hover { background: #455A64; color: #fff; }
        .tab-btn.active {
            background: #102027; 
            color: #00ACC1;
            border-color: #546E7A;
            border-bottom: 1px solid #102027; 
            z-index: 10;
            font-weight: 700;
            padding-bottom: 10px;
            margin-top: -2px;
            padding-top: 10px;
        }

        /* å®Œäº†ã—ãŸã‚¿ãƒ–ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .tab-btn.completed {
            color: #00E676;
            border-bottom: 2px solid #00E676;
        }
        .tab-btn.completed.active {
            color: #00E676;
            border-bottom: 1px solid #102027;
            border-top: 2px solid #00E676;
        }
        .tab-btn.completed::after {
            content: "âœ”";
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 8px;
            color: #00E676;
        }

        /* é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ (é€æ˜åŒ–) */
        .modal-close-btn {
            background: transparent;
            border: none;
            color: #90A4AE;
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 300;
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }
        .modal-close-btn:hover { color: #fff; }
        
        .zukan-scroll-area {
            flex: 1;
            overflow-y: scroll;
            background: #102027;
            border-radius: 4px;
            border-top-left-radius: 0; 
            border: 1px solid #546E7A;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }
        
        .zukan-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px; 
            min-width: 800px; 
        }
        .zukan-item {
            width: 100%;
            aspect-ratio: 4 / 3;
            background: #37474F;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            border: 1px solid #455A64;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .zukan-item.discovered {
            cursor: pointer;
            background: #455A64;
            border-color: #90A4AE;
        }
        .zukan-item.discovered:hover {
            background: #546E7A;
            border-color: #B0BEC5;
        }
        .zukan-item.unknown::after {
            content: "?";
            font-size: 24px;
            color: #546E7A;
            font-weight: bold;
            opacity: 0.5;
            font-family: 'Noto Sans JP', sans-serif;
        }
        .zukan-item canvas {
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
        }
        .zukan-item.discovered canvas { display: block; }
        .zukan-item.discovered::after { display: none; }
        
        .zukan-item .item-number {
            position: absolute;
            top: 4px;
            left: 6px;
            font-size: 15px; 
            font-weight: 500;
            color: rgba(255,255,255,0.4);
            font-family: 'Noto Sans JP', sans-serif;
            text-shadow: none;
            z-index: 5;
            pointer-events: none;
        }

        .zukan-item .block-count {
            position: absolute;
            bottom: 4px;
            left: 6px;
            font-size: 16px; 
            font-weight: 700;
            /* colorã¯JSã§å‹•çš„ã«æŒ‡å®š */
            font-family: 'Noto Sans JP', sans-serif;
            z-index: 5;
            pointer-events: none;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.8);
        }

        .zukan-item .count-badge {
            position: absolute;
            bottom: 4px;
            left: auto;
            right: 6px; /* å³ä¸‹ */
            font-size: 14px;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
            z-index: 5;
            pointer-events: none;
        }
        
        .zukan-item .new-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            bottom: auto;
            background: #F50057;
            color: white;
            font-size: 10px;
            font-weight: 700;
            padding: 1px 6px 3px 6px;
            border-radius: 8px;
            box-shadow: none;
            z-index: 6;
            pointer-events: none;
        }

        .zukan-scroll-area::-webkit-scrollbar { width: 12px; height: 12px; }
        .zukan-scroll-area::-webkit-scrollbar-track { background: #102027; }
        .zukan-scroll-area::-webkit-scrollbar-thumb { background: #546E7A; border-radius: 6px; border: 2px solid #102027; }

        /* è¨­å®šãƒ»ãƒ˜ãƒ«ãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ»çµ±è¨ˆãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
        .settings-content {
            background: #263238;
            padding: 30px;
            border-radius: 4px;
            border: 1px solid #455a64;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            color: #fff;
            width: 300px;
        }
        .settings-content h2 {
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 300;
        }
        .modal-ui-btn {
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 2px;
            cursor: pointer;
            font-weight: 300;
            font-family: 'Noto Sans JP', sans-serif;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-size: 16px;
            transition: all 0.2s;
        }

        /* ã‚¹ã‚¤ãƒƒãƒã‚¹ã‚¿ã‚¤ãƒ« */
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: 300;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #546E7A;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #00ACC1;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .danger-btn {
            background: #D32F2F;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 2px;
            cursor: pointer;
            font-weight: 300;
            font-family: 'Noto Sans JP', sans-serif;
            margin-top: 5px;
            width: 100%;
            font-size: 16px;
        }
        .danger-btn:hover { background: #F44336; }

        /* è©³ç´°è¡¨ç¤ºãƒ¢ãƒ¼ãƒ€ãƒ« */
        #detail-modal {
            background: rgba(0, 0, 0, 0.85);
            z-index: 120;
        }
        .detail-content {
            background: #263238;
            padding: 20px 30px 30px 30px;
            border-radius: 4px;
            border: 2px solid #90A4AE;
            box-shadow: 0 0 50px rgba(255,255,255, 0.1);
            text-align: center;
            color: #fff;
            width: 800px;
            max-width: 95%;
            position: relative;
        }
        .detail-header { margin-bottom: 10px; }
        .detail-header h3 {
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 300;
            font-size: 18px;
            margin: 0;
            color: #90A4AE;
        }
        .detail-number {
            font-size: 28px;
            color: #CFD8DC;
            font-weight: 300;
            margin: 0 0 10px 0;
            font-family: 'Noto Sans JP', sans-serif;
        }
        .detail-info-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 18px; 
            color: #B0BEC5;
            font-family: 'Noto Sans JP', sans-serif;
            margin-bottom: 10px;
            font-weight: 500;
        }
        .detail-canvas-container {
            width: 640px; 
            height: 480px;
            background: #102027;
            margin: 0 auto 0 auto; 
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #455A64;
        }
        .detail-canvas-container canvas { width: 100%; height: 100%; }
        
        .detail-close-x {
            position: absolute;
            top: 15px;
            right: 20px;
            background: transparent;
            border: none;
            color: #90A4AE;
            font-size: 32px;
            font-weight: 300;
            cursor: pointer;
            z-index: 10;
            line-height: 1;
            padding: 0;
            transition: color 0.2s;
        }
        .detail-close-x:hover { color: #fff; }

        /* çµ±è¨ˆãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚°ãƒ©ãƒ•ç”¨ */
        .stat-bar-row {
            display: flex;
            align-items: center;
            font-size: 16px;
            gap: 10px;
            margin-bottom: 4px; /* è©°ã‚ã‚‹ */
        }
        .stat-label {
            width: 30px; 
            text-align: center;
            flex-shrink: 0;
        }
        .stat-bar-container {
            flex: 1;
            position: relative;
            height: 16px;
        }
        .stat-bar-bg {
            background: rgba(255,255,255,0.1);
            height: 100%;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }
        .stat-bar-grid {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 2;
            display: flex;
            justify-content: space-between;
        }
        .grid-line {
            width: 1px;
            height: 100%;
            background: rgba(255,255,255,0.1);
        }
        .stat-bar-fill {
            height: 100%;
            width: 0%;
            transition: width 0.5s ease-out;
        }
        .stat-val {
            width: 40px;
            text-align: left;
            color: #fff;
            flex-shrink: 0;
            font-weight: 500;
            padding-left: 5px;
        }

    </style>
</head>
<body>

<button id="hamburger-btn">â˜°</button>
<div id="side-menu">
    <h1 id="menu-title">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h1>
    <button id="help-menu-btn" class="menu-item-btn"><span>â”ï¸</span>ãƒ˜ãƒ«ãƒ—</button>
    <button id="zukan-menu-btn" class="menu-item-btn"><span>ğŸ“–</span>å›³é‘‘</button>
    <button id="stats-menu-btn" class="menu-item-btn"><span>ğŸ“Š</span>çµ±è¨ˆ</button>
    <button id="clear-menu-btn" class="menu-item-btn"><span>ğŸ§¹</span>ç›¤é¢å…¨å‰Šé™¤</button>
    <button id="settings-menu-btn" class="menu-item-btn"><span>âš™ï¸</span>è¨­å®š</button>
</div>

<div id="clock-display">00:00</div>

<div id="bottom-right-actions">
    <button id="monomino-btn" class="action-circle-btn" disabled>
        <div class="stock-badge" id="monomino-stock">0</div>
        <span class="icon">â– </span>å¬å–š
    </button>

    <button id="zukan-btn" class="action-circle-btn">
        <span>ğŸ“–</span>å›³é‘‘
    </button>
</div>

<div id="toast">New Octomino Discovered!</div>

<div id="help-modal" class="modal-overlay">
    <div class="settings-content" style="width: 600px; max-width: 90%; text-align: left;">
        <h2 style="text-align: center; margin-bottom: 20px;">ã‚„ã‚‹ã“ã¨</h2>
        
        <h3 style="border-bottom: 1px solid #546E7A; padding-bottom: 5px; margin-bottom: 10px;">ç›®çš„</h3>
        <p style="margin-bottom: 20px;">å…¨ç¨®é¡ã®ã‚ªã‚¯ãƒˆãƒŸãƒã€ãŠã‚ˆã³ãƒãƒãƒŸãƒã‚’ä½œã£ã¦ãã ã•ã„</p>

        <h3 style="border-bottom: 1px solid #546E7A; padding-bottom: 5px; margin-bottom: 10px;">ã‚„ã‚‹ã“ã¨</h3>
        <ul style="line-height: 1.8; padding-left: 20px; font-weight: 300; margin-bottom: 20px;">
            <li>å°ã•ãªãƒŸãƒã‚’ä½¿ã£ã¦ãƒãƒªã‚ªãƒŸãƒã‚’ä½œã£ã¦ãã ã•ã„</li>
            <li>ãƒŸãƒã®å¡ŠãŒã‚ªã‚¯ãƒˆãƒŸãƒã¾ãŸã¯ãƒãƒãƒŸãƒã«ãªã‚‹ã¨å…‰ã‚Šã¾ã™</li>
            <li>å…‰ã£ãŸå¡Šã‚’å ±å‘Šã—å›³é‘‘ã«ç™»éŒ²ã—ã¾ã—ã‚‡ã†</li>
            <li>å ±å‘Šã®å ±é…¬ã§ãƒ¢ãƒãƒŸãƒã‚’ä¾›çµ¦ã—ã¾ã™ï¼ˆã‚¹ãƒˆãƒƒã‚¯ä¸Šé™9å€‹ï¼‰</li>
        </ul>
        
        <h3 style="border-bottom: 1px solid #546E7A; padding-bottom: 5px; margin-bottom: 10px;">æ“ä½œæ–¹æ³•</h3>
        <ul style="line-height: 1.8; padding-left: 20px; font-weight: 300;">
            <li>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šãƒŸãƒã‚’2ã¤å‡ºç¾</li>
            <li>ãƒ‰ãƒ©ãƒƒã‚°ï¼šãƒŸãƒã®ç§»å‹•</li>
            <li>ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ï¼šãƒŸãƒã®å›è»¢</li>
            <li>å¡Šã‚’å³ã‚¯ãƒªãƒƒã‚¯ï¼šãƒãƒªã‚ªãƒŸãƒã‚’å ±å‘Š</li>
        </ul>

        <button class="modal-ui-btn" style="background:#00ACC1; margin-top:30px; width:100%; display:block; text-align:center;" id="help-close">é–‰ã˜ã‚‹</button>
    </div>
</div>

<div id="zukan-modal" class="modal-overlay">
    <div class="zukan-content">
        <div class="zukan-header">
            <h2 style="margin:0;">ãƒãƒªã‚ªãƒŸãƒå›³é‘‘ <span id="zukan-count" style="font-size:0.8em; color:#b0bec5;">Generating...</span></h2>
            <button class="modal-close-btn" id="zukan-close">âœ•</button>
        </div>
        
        <div id="category-description">All Items</div>

        <div class="zukan-tabs">
            <button class="tab-btn active" data-tab="all">å…¨</button>
            <button class="tab-btn" data-tab="cat8a">8-A</button> 
            <button class="tab-btn" data-tab="cat8b">8-B</button> 
            <button class="tab-btn" data-tab="cat8c">8-C</button> 
            <button class="tab-btn" data-tab="cat8d">8-D</button> 
            <button class="tab-btn" data-tab="cat8e">8-E</button> 
            <button class="tab-btn" data-tab="cat8f">8-F</button> 
            <button class="tab-btn" data-tab="cat9a">9-A</button>
            <button class="tab-btn" data-tab="cat9b">9-B</button>
            <button class="tab-btn" data-tab="cat9c">9-C</button>
            <button class="tab-btn" data-tab="cat9d">9-D</button>
            <button class="tab-btn" data-tab="cat9e">9-E</button>
            <button class="tab-btn" data-tab="cat9f">9-F</button>
            <button class="tab-btn" data-tab="cat9g">9-G</button>
            <button class="tab-btn" data-tab="cat9h">9-H</button>
            <button class="tab-btn" data-tab="cat9i">9-I</button>
            <button class="tab-btn" data-tab="cat9j">9-J</button>
            <button class="tab-btn" data-tab="cat9k">9-K</button>
        </div>

        <div class="zukan-scroll-area">
            <div class="zukan-grid" id="zukan-list">
                </div>
        </div>
    </div>
</div>

<div id="stats-modal" class="modal-overlay">
    <div class="settings-content" style="width: 600px; max-width:95%; position: relative; padding-top: 40px;">
        <button class="modal-close-btn" id="stats-close-x" style="position: absolute; top: 10px; right: 10px;">âœ•</button>
        
        <h2 style="margin-top:0; margin-bottom: 20px;">çµ±è¨ˆ</h2>
        
        <div id="stats-summary-container"></div>
        
        <h3 style="font-size:14px; margin-bottom:10px; border-bottom:1px solid #455A64; padding-bottom:5px; margin-top: 15px;">ä½¿ç”¨ãƒŸãƒå†…è¨³</h3>
        <div id="stats-bars-container" style="display:flex; flex-direction:column; gap:4px; max-height:400px; overflow-y:auto; padding-right:10px;">
            </div>
    </div>
</div>

<div id="settings-modal" class="modal-overlay">
    <div class="settings-content">
        <h2 style="margin-top:0;">è¨­å®š</h2>
        
        <div class="setting-row">
            <span>åŠ¹æœéŸ³</span>
            <label class="toggle-switch">
                <input type="checkbox" id="se-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div style="border-top: 1px solid #455A64; margin-top: 20px; padding-top: 10px;">
            <h3 style="margin: 0 0 10px 0; font-size: 16px; color: #E57373;">ãƒªã‚»ãƒƒãƒˆ</h3>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <button id="reset-counts-btn" class="danger-btn" style="margin-top:0;">ä½œæˆå›æ•°</button>
                <button id="reset-stats-btn" class="danger-btn" style="margin-top:0;">çµ±è¨ˆãƒ‡ãƒ¼ã‚¿</button>
            </div>
        </div>

        <button class="modal-ui-btn" style="background:#546e7a; margin-top:20px; width:100%; display:block; text-align:center;" id="settings-close">é–‰ã˜ã‚‹</button>
    </div>
</div>

<div id="confirm-modal" class="modal-overlay">
    <div class="settings-content" style="width: 400px; max-width:90%;">
        <h2 style="margin-top:0;">ç¢ºèª</h2>
        <p id="confirm-message" style="margin-bottom:30px; font-weight:500;">
            </p>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button id="confirm-cancel-btn" class="modal-ui-btn" style="background:#546E7A; flex:1;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="confirm-ok-btn" class="danger-btn" style="margin-top:0; flex:1;">å®Ÿè¡Œ</button>
        </div>
    </div>
</div>

<div id="detail-modal" class="modal-overlay">
    <div class="detail-content">
        <button class="detail-close-x" id="detail-close-x">âœ•</button>
        
        <div class="detail-header">
            <h3>è©³ç´°</h3>
            <p id="detail-number" class="detail-number">No.---</p>
            <div class="detail-info-row">
                <span id="detail-date">Latest Crafted: ---</span>
                <span style="border-left: 2px solid #546E7A; margin: 0 10px;"></span>
                <span id="detail-count">Total: 0</span>
            </div>
        </div>
        <div class="detail-canvas-container">
            <canvas id="detail-canvas"></canvas>
        </div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
// --- è¨­å®šå®šæ•° ---
const GRID_SIZE = 50; 
const INV_HEIGHT = 0; 
const GAP_HEIGHT = 0;
const ROT_SPEED = 0.45; 
const CORNER_RADIUS = 8; 

// --- èƒŒæ™¯è‰²ã®å®šç¾© ---
const BG_COLOR_GRID_AREA = '#263238'; 
const BG_COLOR_INV   = '#455A64';

// --- ã‚µã‚¦ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ  (Web Audio API) ---
class SoundSystem {
    constructor() {
        this.ctx = null;
        this.enabled = true;
    }
    init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                this.ctx = new AudioContext();
            }
        }
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume().catch(e => console.log(e));
        }
    }
    toggleMute(isMuted) {
        this.enabled = !isMuted;
    }
    playDrop() {
        if (!this.enabled) return;
        this.playTone('sine', 200, 50, 0.1, 0.15);
    }
    playRotate() {
        if (!this.enabled) return;
        this.playTone('sine', 400, 100, 0.05, 0.05);
    }
    // å‡ºç¾éŸ³ (éŸ³é‡0.04)
    playSpawn() {
        if (!this.enabled || !this.ctx) return;
        this.init();

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.type = 'square';
        osc.frequency.setValueAtTime(300, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);

        gain.gain.setValueAtTime(0.04, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }
    // æ–°è¦ç™»éŒ²éŸ³
    playNewDiscovery() {
        if (!this.enabled) return;
        this.playTone('sine', 2000, 4000, 0.1, 0.1); 
    }
    // æ—¢å‡º
    playAlreadyKnown() {
        if (!this.enabled) return;
        this.playTone('sawtooth', 150, 50, 0.1, 0.05);
    }

    playTone(type, startFreq, endFreq, duration, volume) {
        if (!this.enabled || !this.ctx) return;
        this.init();

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(endFreq, this.ctx.currentTime + duration);

        gain.gain.setValueAtTime(volume, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
}

// --- å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿ã®å®šç¾© ---
const SHAPES = [
    [[0,0]],                      // 0: Monomino
    [[0,0], [1,0]],               // 1: Domino
    [[0,0], [1,0], [2,0]],        // 2: Tromino I
    [[0,0], [1,0], [0,1]],        // 3: Tromino L
    [[0,0], [1,0], [2,0], [3,0]], // 4: Tetromino I
    [[0,0], [1,0], [0,1], [1,1]], // 5: Tetromino O
    [[0,0], [1,0], [2,0], [1,1]], // 6: Tetromino T
    [[0,0], [1,0], [2,0], [0,1]], // 7: Tetromino L
    [[0,0], [1,0], [2,0], [2,1]], // 8: Tetromino J
    [[1,0], [2,0], [0,1], [1,1]], // 9: Tetromino S
    [[0,0], [1,0], [1,1], [2,1]]  // 10: Tetromino Z
];

const SHAPE_NAMES = [
    "m", "d", "a", "b", "i", "o", "t", "l", "j", "s", "z"
];

// --- é…è‰²ãƒ­ã‚¸ãƒƒã‚¯ ---
const SHAPE_COLORS = [
    '#546E7A', '#FFC400', '#00B0FF', '#E040FB', '#1DE9B6', 
    '#FF9100', '#651FFF', '#FF3D00', '#2979FF', '#00E676', '#F50057'
];

// --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
const normalizeShape = (points) => {
    let mx = Infinity, my = Infinity;
    points.forEach(p => { if(p.x<mx) mx=p.x; if(p.y<my) my=p.y; });
    let current = points.map(p => ({x: p.x - mx, y: p.y - my}));

    const variants = [];
    const serialize = (pts) => {
        let mnx=Infinity, mny=Infinity;
        pts.forEach(p=>{if(p.x<mnx)mnx=p.x;if(p.y<mny)mny=p.y;});
        const norm = pts.map(p=>({x:p.x-mnx, y:p.y-mny}));
        norm.sort((a,b) => a.x===b.x ? a.y-b.y : a.x-b.x);
        return norm.map(p=>`${p.x},${p.y}`).join(';');
    };

    const rotate = (p) => ({x: -p.y, y: p.x});
    const reflect = (p) => ({x: p.x, y: -p.y});

    for(let i=0; i<4; i++) {
        variants.push(serialize(current));
        variants.push(serialize(current.map(reflect)));
        current = current.map(rotate);
    }
    variants.sort();
    return variants[0];
};

const adjustOrientationForDisplay = (points) => {
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    points.forEach(p => {
        if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x;
        if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y;
    });
    const w = maxX - minX + 1;
    const h = maxY - minY + 1;

    if (w >= h) {
         return points.map(p => ({x: p.x - minX, y: p.y - minY}));
    }
    const rotated = points.map(p => ({x: -p.y, y: p.x}));
    let rMinX=Infinity, rMinY=Infinity;
    rotated.forEach(p => {
        if(p.x<rMinX)rMinX=p.x;
        if(p.y<rMinY)rMinY=p.y;
    });
    return rotated.map(p => ({x: p.x - rMinX, y: p.y - rMinY}));
};

const rotateShapePoints = (blocks, times) => {
    let current = JSON.parse(JSON.stringify(blocks));
    for(let i=0; i<times; i++) {
        current = current.map(([x, y]) => [-y, x]);
    }
    let minX = Infinity, minY = Infinity;
    current.forEach(([x, y]) => {
        if(x < minX) minX = x;
        if(y < minY) minY = y;
    });
    return current.map(([x, y]) => [x - minX, y - minY]);
};

const drawZukanPolyomino = (ctx, blocks, logicalW, logicalH, color = '#CFD8DC', boneColor = 'rgba(0,0,0,0.15)') => {
    ctx.clearRect(0, 0, logicalW, logicalH);

    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    blocks.forEach(p=>{
        if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x;
        if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y;
    });
    const w = maxX - minX + 1;
    const h = maxY - minY + 1;

    const maxBlocksWidth = 9.0; 
    const blockSize = logicalW / maxBlocksWidth;

    const drawingW = w * blockSize;
    const drawingH = h * blockSize;
    const offsetX = (logicalW - drawingW) / 2 - minX * blockSize;
    const offsetY = (logicalH - drawingH) / 2 - minY * blockSize;

    const has = (x, y) => blocks.some(b => b.x===x && b.y===y);

    ctx.fillStyle = color;
    ctx.beginPath();
    const r = blockSize * 0.15; 
    for(let b of blocks) {
        const x = offsetX + b.x * blockSize;
        const y = offsetY + b.y * blockSize;
        const s = blockSize;

        const u = has(b.x, b.y-1);
        const d = has(b.x, b.y+1);
        const l = has(b.x-1, b.y);
        const ri = has(b.x+1, b.y);

        if(l||u) ctx.moveTo(x,y); else {ctx.moveTo(x,y+r);ctx.arcTo(x,y,x+r,y,r);}
        if(ri||u) ctx.lineTo(x+s,y); else {ctx.lineTo(x+s-r,y);ctx.arcTo(x+s,y,x+s,y+r,r);}
        if(ri||d) ctx.lineTo(x+s,y+s); else {ctx.lineTo(x+s,y+s-r);ctx.arcTo(x+s,y+s,x+s-r,y+s,r);}
        if(l||d) ctx.lineTo(x,y+s); else {ctx.lineTo(x+r,y+s);ctx.arcTo(x,y+s,x,y+s-r,r);}
    }
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 4;
    ctx.fill();
    ctx.shadowBlur = 0; 

    const centerOff = blockSize / 2;
    ctx.strokeStyle = boneColor;
    ctx.lineWidth = blockSize * 0.05;
    ctx.lineCap = 'round';
    
    ctx.beginPath();
    for(let b of blocks) {
        const cx = offsetX + b.x * blockSize + centerOff;
        const cy = offsetY + b.y * blockSize + centerOff;
        if(has(b.x+1, b.y)) { ctx.moveTo(cx, cy); ctx.lineTo(cx+blockSize, cy); }
        if(has(b.x, b.y+1)) { ctx.moveTo(cx, cy); ctx.lineTo(cx, cy+blockSize); }
    }
    ctx.stroke();

    ctx.fillStyle = 'rgba(0,0,0,0.2)'; 
    for(let b of blocks) {
        const cx = offsetX + b.x * blockSize + centerOff;
        const cy = offsetY + b.y * blockSize + centerOff;
        ctx.beginPath();
        ctx.arc(cx, cy, blockSize*0.08, 0, Math.PI*2);
        ctx.fill();
    }
};

const showCustomConfirm = (message, onOk) => {
    const modal = document.getElementById('confirm-modal');
    const msgEl = document.getElementById('confirm-message');
    const okBtn = document.getElementById('confirm-ok-btn');
    const cancelBtn = document.getElementById('confirm-cancel-btn');

    msgEl.textContent = message;
    
    const close = () => {
        modal.classList.remove('active');
        okBtn.onclick = null;
        cancelBtn.onclick = null;
    };

    okBtn.onclick = () => {
        onOk();
        close();
    };
    cancelBtn.onclick = close;

    modal.classList.add('active');
};

// --- å›³é‘‘ã‚·ã‚¹ãƒ†ãƒ  (ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾å¿œç‰ˆ) ---
class Zukan {
    constructor() {
        this.allIds = []; 
        this.collected = new Set();
        this.viewed = new Set();
        this.timestamps = new Map();
        
        this.counts = new Map();
        this.materialCounts = new Array(11).fill(0);
        this.totalReports = 0;

        // è¨ˆç®—çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹Mapã‚’è¿½åŠ 
        this.shapeCache = new Map();

        this.container = document.getElementById('zukan-list');
        this.countLabel = document.getElementById('zukan-count');
        this.descLabel = document.getElementById('category-description');
        
        this.modal = document.getElementById('zukan-modal');
        this.settingsModal = document.getElementById('settings-modal');
        this.statsModal = document.getElementById('stats-modal');
        
        this.detailModal = document.getElementById('detail-modal');
        this.detailCanvas = document.getElementById('detail-canvas');
        this.detailNumber = document.getElementById('detail-number');
        this.detailDate = document.getElementById('detail-date');
        this.detailCount = document.getElementById('detail-count');
        
        this.currentTab = 'all'; 
        this.tabButtons = document.querySelectorAll('.tab-btn');
        this.tabButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.tabButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.currentTab = btn.getAttribute('data-tab');
                this.buildUI();
            });
        });

        this.load();

        document.getElementById('zukan-btn').addEventListener('click', () => this.openZukan());
        document.getElementById('zukan-menu-btn').addEventListener('click', () => this.openZukan()); 
        document.getElementById('zukan-close').addEventListener('click', () => this.closeZukan());
        
        document.getElementById('settings-menu-btn').addEventListener('click', () => this.openSettings());
        document.getElementById('settings-close').addEventListener('click', () => this.closeSettings());
        
        document.getElementById('reset-counts-btn').addEventListener('click', () => this.resetCounts());
        document.getElementById('reset-stats-btn').addEventListener('click', () => this.resetStats());

        document.getElementById('stats-menu-btn').addEventListener('click', () => this.openStats());
        document.getElementById('stats-close-x').addEventListener('click', () => this.closeStats());
        
        document.getElementById('detail-close-x').addEventListener('click', () => this.detailModal.classList.remove('active'));

        // â˜…åˆæœŸåŒ–å‡¦ç†å¤‰æ›´ï¼šã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°èª­ã¿è¾¼ã¿ã€ãªã‘ã‚Œã°ç”Ÿæˆãƒ»ä¿å­˜
        this.initShapeData();
    }

    initShapeData() {
        try {
            const savedShapes = localStorage.getItem('octomino_master_shape_db');
            if (savedShapes) {
                // ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯è¨ˆç®—ã›ãšã«èª­ã¿è¾¼ã‚€
                this.allIds = JSON.parse(savedShapes);
                // ã‚«ãƒ†ã‚´ãƒªæƒ…å ±ãªã©ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ§‹ç¯‰ï¼ˆè»½é‡ï¼‰
                this.allIds.forEach(id => this.getShapeInfo(id));
                this.buildUI();
                console.log("Loaded shape data from cache.");
            } else {
                // ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã®ã¿è¨ˆç®—å‡¦ç†ã‚’å®Ÿè¡Œ
                console.log("Generating shape data...");
                setTimeout(() => this.generateAndSaveShapes(), 100);
            }
        } catch (e) {
            console.error("Failed to load shape data", e);
            setTimeout(() => this.generateAndSaveShapes(), 100);
        }
    }

    openZukan() { 
        this.modal.classList.add('active'); 
        document.getElementById('side-menu').classList.remove('active');
    }
    closeZukan() { this.modal.classList.remove('active'); }
    
    openSettings() { 
        this.settingsModal.classList.add('active'); 
        document.getElementById('side-menu').classList.remove('active');
    }
    closeSettings() { this.settingsModal.classList.remove('active'); }

    openStats() {
        this.buildStatsUI();
        this.statsModal.classList.add('active');
        document.getElementById('side-menu').classList.remove('active');
    }
    closeStats() { this.statsModal.classList.remove('active'); }

    buildStatsUI() {
        let octoCount = 0;
        let nonoCount = 0;
        
        this.counts.forEach((val, id) => {
            const points = id.split(';');
            if (points.length === 8) octoCount += val;
            else if (points.length === 9) nonoCount += val;
        });

        const summaryContainer = document.getElementById('stats-summary-container');
        summaryContainer.innerHTML = `
            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; text-align:center; margin-bottom:15px;">
                <div>
                    <div style="font-size:12px; color:#B0BEC5">Total</div>
                    <div style="font-size:24px; font-weight:500">${this.totalReports}</div>
                </div>
                <div>
                    <div style="font-size:12px; color:#4FC3F7">Octomino</div>
                    <div style="font-size:24px; font-weight:500">${octoCount}</div>
                </div>
                <div>
                    <div style="font-size:12px; color:#F06292">Nonomino</div>
                    <div style="font-size:24px; font-weight:500">${nonoCount}</div>
                </div>
            </div>
        `;
        
        const container = document.getElementById('stats-bars-container');
        container.innerHTML = '';

        let maxVal = Math.max(...this.materialCounts, 1);
        
        let scaleMax = maxVal;
        const digits = Math.floor(Math.log10(maxVal));
        const p = Math.pow(10, digits);
        const lead = maxVal / p;
        
        if (lead <= 1) scaleMax = 1 * p;       
        else if (lead <= 2) scaleMax = 2 * p;  
        else if (lead <= 5) scaleMax = 5 * p;  
        else scaleMax = 10 * p;
        
        if (scaleMax < maxVal) {
            if (lead > 5) scaleMax = 10 * p;
            else if (lead > 2) scaleMax = 5 * p;
            else scaleMax = 2 * p;
        }
        
        const gridLines = [];
        for (let i = 1; i < 4; i++) {
            gridLines.push(i * 25);
        }

        SHAPE_NAMES.forEach((name, i) => {
            const count = this.materialCounts[i];
            const percent = (count / scaleMax) * 100;
            const color = SHAPE_COLORS[i];

            const row = document.createElement('div');
            row.className = 'stat-bar-row';
            
            let grids = '';
            gridLines.forEach(pos => {
                grids += `<div class="grid-line" style="left:${pos}%"></div>`;
            });

            row.innerHTML = `
                <div class="stat-label" style="color: ${color}; font-weight: 700;">${name}</div>
                <div class="stat-bar-container">
                    <div class="stat-bar-bg">
                        <div class="stat-bar-grid">${grids}</div>
                        <div class="stat-bar-fill" style="width: ${percent}%; background-color: ${color};"></div>
                    </div>
                </div>
                <div class="stat-val">${count}</div>
            `;
            container.appendChild(row);
        });
        
        const axisRow = document.createElement('div');
        axisRow.style.display = 'flex';
        axisRow.style.paddingLeft = '30px'; 
        axisRow.style.paddingRight = '40px'; 
        axisRow.style.fontSize = '10px';
        axisRow.style.color = '#546E7A';
        axisRow.style.justifyContent = 'space-between';
        
        [0, 0.25, 0.5, 0.75, 1].forEach(r => {
            const span = document.createElement('span');
            span.textContent = Math.round(scaleMax * r);
            span.style.width = '20px';
            span.style.textAlign = 'center';
            axisRow.appendChild(span);
        });
        container.appendChild(axisRow);
    }

    save() {
        try {
            const data = JSON.stringify(Array.from(this.collected));
            localStorage.setItem('octomino_zukan_collection', data);
            
            const times = {};
            this.timestamps.forEach((val, key) => times[key] = val);
            localStorage.setItem('octomino_zukan_timestamps', JSON.stringify(times));

            const viewedData = JSON.stringify(Array.from(this.viewed));
            localStorage.setItem('octomino_zukan_viewed', viewedData);

            const countsObj = {};
            this.counts.forEach((val, key) => countsObj[key] = val);
            localStorage.setItem('octomino_zukan_counts', JSON.stringify(countsObj));
            
            localStorage.setItem('octomino_zukan_stats_materials', JSON.stringify(this.materialCounts));
            localStorage.setItem('octomino_zukan_stats_total', String(this.totalReports));

        } catch(e) { console.error(e); }
    }

    load() {
        try {
            const data = localStorage.getItem('octomino_zukan_collection');
            if(data) {
                const arr = JSON.parse(data);
                this.collected = new Set(arr);
            }
            const timeData = localStorage.getItem('octomino_zukan_timestamps');
            if(timeData) {
                const times = JSON.parse(timeData);
                for(let key in times) {
                    this.timestamps.set(key, times[key]);
                }
            }
            const viewedData = localStorage.getItem('octomino_zukan_viewed');
            if(viewedData) {
                const arr = JSON.parse(viewedData);
                this.viewed = new Set(arr);
            }

            const countsData = localStorage.getItem('octomino_zukan_counts');
            if (countsData) {
                const cObj = JSON.parse(countsData);
                for (let key in cObj) {
                    this.counts.set(key, cObj[key]);
                }
            } else {
                this.collected.forEach(id => {
                    if (!this.counts.has(id)) this.counts.set(id, 1);
                });
            }

            const matData = localStorage.getItem('octomino_zukan_stats_materials');
            if (matData) {
                this.materialCounts = JSON.parse(matData);
            }
            const totalData = localStorage.getItem('octomino_zukan_stats_total');
            if (totalData) {
                this.totalReports = parseInt(totalData, 10) || 0;
            }

        } catch(e) { console.error(e); }
    }

    resetCounts() {
        showCustomConfirm("ä½œæˆå›æ•°ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™\n(ç™ºè¦‹çŠ¶æ³ã¯ç¶­æŒã•ã‚Œã¾ã™)", () => {
            this.counts.clear();
            localStorage.setItem('octomino_zukan_counts', '{}');
            this.closeSettings();
            this.buildUI();
            this.showResetToast();
        });
    }

    resetStats() {
        showCustomConfirm("çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™\n(ä½¿ç”¨ãƒŸãƒå†…è¨³ã¨ç·å ±å‘Šæ•°)", () => {
            this.materialCounts = new Array(11).fill(0);
            this.totalReports = 0;
            localStorage.removeItem('octomino_zukan_stats_materials');
            localStorage.removeItem('octomino_zukan_stats_total');
            this.closeSettings();
            this.showResetToast();
        });
    }

    showResetToast() {
        const toast = document.getElementById('toast');
        toast.textContent = "ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ";
        toast.className = 'show alert';
        setTimeout(() => { toast.classList.remove('show'); toast.classList.remove('alert'); }, 2000);
    }

    getShapeInfo(id) {
        if (this.shapeCache.has(id)) {
            return this.shapeCache.get(id);
        }

        const points = id.split(';').map(s => { 
            const [x, y] = s.split(','); 
            return { x: +x, y: +y }; 
        });

        // è¾ºã®é•·ã•è¨ˆç®—
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        points.forEach(p => {
            if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
        });
        const w = maxX - minX + 1;
        const h = maxY - minY + 1;
        const s = Math.min(w, h);
        const l = Math.max(w, h);
        const len = points.length;

        // 2x2ã®å¡Šåˆ¤å®š
        let has2x2 = false;
        if (len === 9) {
            const pSet = new Set(id.split(';'));
            for (let p of points) {
                if (pSet.has(`${p.x+1},${p.y}`) && 
                    pSet.has(`${p.x},${p.y+1}`) && 
                    pSet.has(`${p.x+1},${p.y+1}`)) {
                    has2x2 = true;
                    break;
                }
            }
        }

        // ã‚«ãƒ†ã‚´ãƒªåˆ¤å®š
        let cat = '';
        if (len === 8) {
            if (s <= 2) cat = 'cat8a';
            else if (s === 3) {
                if (l <= 4) cat = 'cat8b';
                else if (l === 5) cat = 'cat8c';
                else cat = 'cat8d';
            } else { // s >= 4
                if (l === 4) cat = 'cat8e';
                else cat = 'cat8f';
            }
        } else if (len === 9) {
            if (s <= 2) cat = 'cat9a';
            else if (s === 3) {
                if (l <= 4) cat = 'cat9b';
                else if (l === 5) cat = 'cat9c';
                else if (l === 6) {
                    if (has2x2) cat = 'cat9d';
                    else cat = 'cat9e';
                } else {
                    cat = 'cat9f';
                }
            } else if (s === 4) {
                if (l === 4) cat = 'cat9g';
                else if (l === 5) {
                    if (has2x2) cat = 'cat9h';
                    else cat = 'cat9i';
                } else {
                    cat = 'cat9j';
                }
            } else {
                cat = 'cat9k';
            }
        }

        const info = { points, s, l, len, has2x2, cat };
        this.shapeCache.set(id, info);
        return info;
    }

    // â˜…å¤‰æ›´: åå‰ã‚’å¤‰æ›´ã—ã€ä¿å­˜æ©Ÿèƒ½ã‚’è¿½åŠ ã—ãŸç”Ÿæˆãƒ¡ã‚½ãƒƒãƒ‰
    generateAndSaveShapes() {
        let currentShapes = [ [{x:0,y:0}] ];
        let collectedShapes = [];

        for(let n=2; n<=9; n++) {
            const nextShapesSet = new Set();
            const nextShapes = [];
            for(let shape of currentShapes) {
                for(let block of shape) {
                    const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                    for(let d of dirs) {
                        const nx = block.x + d.x;
                        const ny = block.y + d.y;
                        if(shape.some(b => b.x===nx && b.y===ny)) continue;
                        const newShape = [...shape, {x:nx, y:ny}];
                        const id = normalizeShape(newShape);
                        if(!nextShapesSet.has(id)) {
                            nextShapesSet.add(id);
                            const points = id.split(';').map(s => { const [x,y]=s.split(','); return {x:+x, y:+y}; });
                            nextShapes.push(points);
                        }
                    }
                }
            }
            currentShapes = nextShapes;
            
            if (n === 8 || n === 9) {
                collectedShapes = collectedShapes.concat(currentShapes);
            }
        }
        
        let ids = collectedShapes.map(s => normalizeShape(s));
        
        // ã‚½ãƒ¼ãƒˆå‡¦ç†ã®æœ€é©åŒ–ï¼šã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸã‚«ãƒ†ã‚´ãƒªIDã§æ¯”è¼ƒ
        ids.sort((a, b) => {
            const infoA = this.getShapeInfo(a);
            const infoB = this.getShapeInfo(b);
            
            if (infoA.cat !== infoB.cat) {
                return infoA.cat < infoB.cat ? -1 : 1;
            }
            return a.localeCompare(b);
        });

        this.allIds = ids;
        
        // â˜…è¿½åŠ : è¨ˆç®—çµæœã‚’localStorageã«ä¿å­˜ï¼ˆæ¬¡å›ä»¥é™ã®ãŸã‚ï¼‰
        try {
            localStorage.setItem('octomino_master_shape_db', JSON.stringify(ids));
            console.log("Shape data generated and saved to cache.");
        } catch(e) {
            console.error("Failed to save shape cache", e);
        }

        this.buildUI();
    }

    buildUI() {
        this.container.innerHTML = '';
        const dpr = window.devicePixelRatio || 1;
        const itemW = 160; 
        const itemH = 120; 
        
        const catDescriptions = {
            'all': "ã™ã¹ã¦",
            'cat8a': "çŸ­è¾º2-",
            'cat8b': "çŸ­è¾º3Ã—é•·è¾º4-",
            'cat8c': "çŸ­è¾º3Ã—é•·è¾º5",
            'cat8d': "çŸ­è¾º3Ã—é•·è¾º6+",
            'cat8e': "çŸ­è¾º4Ã—é•·è¾º4",
            'cat8f': "çŸ­è¾º4Ã—é•·è¾º5+",
            
            'cat9a': "çŸ­è¾º2-",
            'cat9b': "çŸ­è¾º3Ã—é•·è¾º4-",
            'cat9c': "çŸ­è¾º3Ã—é•·è¾º5",
            'cat9d': "çŸ­è¾º3Ã—é•·è¾º6 / 2Ã—2ã®å¡Šã‚’å«ã‚€",
            'cat9e': "çŸ­è¾º3Ã—é•·è¾º6 / 2Ã—2ã®å¡Šã‚’å«ã¾ãªã„",
            'cat9f': "çŸ­è¾º3Ã—é•·è¾º7+",
            'cat9g': "çŸ­è¾º4Ã—é•·è¾º4",
            'cat9h': "çŸ­è¾º4Ã—é•·è¾º5 / 2Ã—2ã®å¡Šã‚’å«ã‚€",
            'cat9i': "çŸ­è¾º4Ã—é•·è¾º5 / 2Ã—2ã®å¡Šã‚’å«ã¾ãªã„",
            'cat9j': "çŸ­è¾º4Ã—é•·è¾º6+", 
            'cat9k': "çŸ­è¾º5+"
        };
        
        this.descLabel.textContent = catDescriptions[this.currentTab] || "";
        
        if (this.currentTab.startsWith('cat8')) {
            this.descLabel.style.borderLeftColor = '#00ACC1'; 
        } else if (this.currentTab.startsWith('cat9')) {
            this.descLabel.style.borderLeftColor = '#a743e0'; 
        } else {
            this.descLabel.style.borderLeftColor = '#546E7A'; 
        }

        // --- ã‚¿ãƒ–ã®çŠ¶æ…‹æ›´æ–° (ã‚³ãƒ³ãƒ—ãƒªãƒ¼ãƒˆåˆ¤å®š) ---
        this.tabButtons.forEach(btn => {
            const tabCat = btn.getAttribute('data-tab');
            
            // å…¨ã‚¢ã‚¤ãƒ†ãƒ ãƒ­ãƒ¼ãƒ‰å‰ã¯ã‚¹ã‚­ãƒƒãƒ—
            if (this.allIds.length === 0) return;

            // ã‚«ãƒ†ã‚´ãƒªãƒ¼ã”ã¨ã®å®Œäº†åˆ¤å®š
            let isCompleted = false;
            if (tabCat === 'all') {
                isCompleted = (this.collected.size === this.allIds.length);
            } else {
                const catIds = this.allIds.filter(id => this.getShapeInfo(id).cat === tabCat);
                if (catIds.length > 0) {
                    const collectedCount = catIds.filter(id => this.collected.has(id)).length;
                    isCompleted = (collectedCount === catIds.length);
                }
            }

            if (isCompleted) {
                btn.classList.add('completed');
            } else {
                btn.classList.remove('completed');
            }
        });

        // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã®æœ€é©åŒ–ï¼šã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’åˆ©ç”¨
        const visibleIds = this.allIds.filter(id => {
            if (this.currentTab === 'all') return true;
            const info = this.getShapeInfo(id);
            return info.cat === this.currentTab;
        });

        visibleIds.forEach(id => {
            const globalIndex = this.allIds.indexOf(id); 
            const info = this.getShapeInfo(id);

            const div = document.createElement('div');
            const isDiscovered = this.collected.has(id);
            div.className = isDiscovered ? 'zukan-item discovered' : 'zukan-item unknown';
            div.id = 'zukan-' + id.replace(/[,;]/g, '_');
            
            const numSpan = document.createElement('span');
            numSpan.className = 'item-number';
            numSpan.textContent = `#${globalIndex + 1}`;
            div.appendChild(numSpan);
            
            const countSpan = document.createElement('span');
            countSpan.className = 'block-count';
            countSpan.textContent = info.len;
            countSpan.style.color = (info.len === 9) ? '#E1BEE7' : '#B3E5FC';
            
            div.appendChild(countSpan);

            if (isDiscovered && !this.viewed.has(id)) {
                const badge = document.createElement('span');
                badge.className = 'new-badge';
                badge.textContent = 'NEW';
                div.appendChild(badge);
            }
            
            if (isDiscovered) {
                const count = this.counts.get(id) || 1;
                const countBadge = document.createElement('span');
                countBadge.className = 'count-badge';
                countBadge.textContent = `Ã—${count}`;
                div.appendChild(countBadge);
            }
            
            div.onclick = () => {
                if (div.classList.contains('discovered')) {
                    this.showDetail(id);
                }
            };

            const canvas = document.createElement('canvas');
            canvas.width = itemW * dpr;
            canvas.height = itemH * dpr;
            div.appendChild(canvas);
            
            this.container.appendChild(div);

            if (isDiscovered) {
                const ctx = canvas.getContext('2d');
                let points = id.split(';').map(s => { const [x,y]=s.split(','); return {x:+x, y:+y}; });
                points = adjustOrientationForDisplay(points);
                ctx.scale(dpr, dpr);
                
                const fillColor = info.len === 9 ? '#E1BEE7' : '#B3E5FC'; 
                
                drawZukanPolyomino(ctx, points, itemW, itemH, fillColor);
            }
        });
        this.updateCount();
    }

    showDetail(id) {
        if (!this.viewed.has(id)) {
            this.viewed.add(id);
            this.save();
            const divId = 'zukan-' + id.replace(/[,;]/g, '_');
            const div = document.getElementById(divId);
            if (div) {
                const badge = div.querySelector('.new-badge');
                if (badge) badge.remove();
            }
        }

        let points = id.split(';').map(s => { const [x,y]=s.split(','); return {x:+x, y:+y}; });
        const length = points.length;
        points = adjustOrientationForDisplay(points);
        
        const dpr = window.devicePixelRatio || 1;
        const cssW = 640; 
        const cssH = 480;
        
        this.detailCanvas.width = cssW * dpr;
        this.detailCanvas.height = cssH * dpr;
        this.detailCanvas.style.width = '100%';
        this.detailCanvas.style.height = '100%';

        const ctx = this.detailCanvas.getContext('2d');
        ctx.resetTransform();
        ctx.scale(dpr, dpr);

        const index = this.allIds.indexOf(id);
        this.detailNumber.textContent = `No.${index + 1}`;
        
        const dateStr = this.timestamps.get(id) || '---';
        this.detailDate.textContent = `Latest: ${dateStr}`; 

        const count = this.counts.get(id) || 0;
        this.detailCount.textContent = `Total: ${count}`;
        
        const fillColor = length === 9 ? '#E1BEE7' : '#B3E5FC';
        drawZukanPolyomino(ctx, points, cssW, cssH, fillColor);
        
        this.detailModal.classList.add('active');
    }

    register(blocks, consumedTypeIds) {
        if(blocks.length !== 8 && blocks.length !== 9) return false;
        
        const id = normalizeShape(blocks);
        if(!this.allIds.includes(id)) return {isNew: false, id: id, index: -1};

        const index = this.allIds.indexOf(id);
        const isNew = !this.collected.has(id);

        if(isNew) {
            this.collected.add(id);
        }
        
        const now = new Date().toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });
        this.timestamps.set(id, now);
        
        const currentCount = this.counts.get(id) || 0;
        this.counts.set(id, currentCount + 1);

        this.totalReports++;
        if (consumedTypeIds && consumedTypeIds.length > 0) {
            consumedTypeIds.forEach(tId => {
                if (tId >= 0 && tId < this.materialCounts.length) {
                    this.materialCounts[tId]++;
                }
            });
        }
        
        this.save();
        this.unlockItem(id);
        this.updateCount();
        
        return {isNew: isNew, id: id, index: index, length: blocks.length};
    }

    unlockItem(id) {
        const divId = 'zukan-' + id.replace(/[,;]/g, '_');
        const div = document.getElementById(divId);
        
        if(div) {
            div.classList.remove('unknown');
            div.classList.add('discovered');
            
            let countSpan = div.querySelector('.count-badge');
            if (!countSpan) {
                countSpan = document.createElement('span');
                countSpan.className = 'count-badge';
                div.appendChild(countSpan);
            }
            const count = this.counts.get(id) || 1;
            countSpan.textContent = `Ã—${count}`;

            const canvas = div.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            let points = id.split(';').map(s => { const [x,y]=s.split(','); return {x:+x, y:+y}; });
            const length = points.length;
            
            points = adjustOrientationForDisplay(points);
            
            const dpr = window.devicePixelRatio || 1;
            const logicalW = 160; 
            const logicalH = 120;

            ctx.resetTransform();
            ctx.scale(dpr, dpr);
            
            const fillColor = length === 9 ? '#E1BEE7' : '#B3E5FC';
            
            drawZukanPolyomino(ctx, points, logicalW, logicalH, fillColor);

            if (!this.viewed.has(id) && !div.querySelector('.new-badge')) {
                const badge = document.createElement('span');
                badge.className = 'new-badge';
                badge.textContent = 'NEW';
                div.appendChild(badge);
            }
        }
    }

    updateCount() {
        const totalAll = this.allIds.length;
        
        // ã¾ã ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆå‰ãªã‚‰ä½•ã‚‚ã—ãªã„
        if (totalAll === 0) return;

        let currentCount = 0;
        let totalCount = 0;

        if (this.currentTab === 'all') {
            currentCount = this.collected.size;
            totalCount = totalAll;
            this.countLabel.textContent = `${currentCount} / ${totalCount}`;
        } else {
            // ç¾åœ¨ã®ã‚¿ãƒ–ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼ã«å±ã™ã‚‹IDã®ã¿ã‚’æŠ½å‡ºã—ã¦ã‚«ã‚¦ãƒ³ãƒˆ
            const categoryIds = this.allIds.filter(id => {
                const info = this.getShapeInfo(id);
                return info.cat === this.currentTab;
            });
            
            totalCount = categoryIds.length;
            currentCount = categoryIds.filter(id => this.collected.has(id)).length;
            
            this.countLabel.textContent = `${currentCount} / ${totalCount}`;
        }

        // ã‚³ãƒ³ãƒ—ãƒªãƒ¼ãƒˆæ™‚ã¯æ•°å­—ã‚’ç·‘è‰²ã«ã™ã‚‹æ¼”å‡º
        if (totalCount > 0 && currentCount === totalCount) {
            this.countLabel.style.color = '#00E676';
        } else {
            this.countLabel.style.color = '#b0bec5';
        }
    }
}

// --- Polyomino (ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¯¾å¿œç‰ˆ) ---
class Polyomino {
    constructor(blocks, x, y, color, typeId) {
        this.blocks = JSON.parse(JSON.stringify(blocks));
        this.x = x; 
        this.y = y;
        this.color = color;
        this.typeId = typeId;
        
        this.isDragging = false;
        this.inInventory = true;
        this.slotIndex = -1;

        this.currentRotation = 0; 
        this.targetRotation = 0;
        this.isAnimating = false;

        this.prevX = x;
        this.prevY = y;
        this.prevInInventory = true;

        this.pivotIndex = 0;
        this.determinePivotBlock();

        this.scale = 1;
        this.opacity = 1; 
        this.animState = 'idle'; 
        this.animProgress = 0;
        
        // --- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ– ---
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCtx = this.cacheCanvas.getContext('2d');
        this.cacheOffsetX = 0;
        this.cacheOffsetY = 0;
        this.prerender();
    }

    serialize() {
        return {
            blocks: this.blocks,
            x: this.x,
            y: this.y,
            color: this.color,
            typeId: this.typeId
        };
    }

    static deserialize(d) {
        return new Polyomino(d.blocks, d.x, d.y, d.color, d.typeId);
    }

    startAppearAnimation() {
        this.animState = 'appearing';
        this.animProgress = 0;
        this.scale = 0.5; 
        this.opacity = 0; 
    }

    startDeleteAnimation() {
        this.animState = 'deleting';
        this.animProgress = 0;
    }

    determinePivotBlock() {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        this.blocks.forEach(([bx, by]) => {
            minX = Math.min(minX, bx); maxX = Math.max(maxX, bx);
            minY = Math.min(minY, by); maxY = Math.max(maxY, by);
        });
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;

        let minDist = Infinity;
        let bestIndex = 0;

        this.blocks.forEach((b, i) => {
            const dist = (b[0] - cx)**2 + (b[1] - cy)**2;
            if (dist < minDist) {
                minDist = dist;
                bestIndex = i;
            }
        });
        this.pivotIndex = bestIndex;
    }

    simulateRotation(dir) {
        let rotatedBlocks = this.blocks.map(([x, y]) => {
            return dir === 1 ? [-y, x] : [y, -x];
        });

        let minX = Infinity, minY = Infinity;
        rotatedBlocks.forEach(([x,y]) => {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
        });
        rotatedBlocks = rotatedBlocks.map(([x,y]) => [x - minX, y - minY]);

        if (this.typeId === 5) {
            return { blocks: rotatedBlocks, x: this.x, y: this.y };
        }

        const pivotBlock = this.blocks[this.pivotIndex];
        const pivotAbsX = this.x + pivotBlock[0] * GRID_SIZE;
        const pivotAbsY = this.y + pivotBlock[1] * GRID_SIZE;

        const newPivotBlock = rotatedBlocks[this.pivotIndex];
        const newRelX = newPivotBlock[0] * GRID_SIZE;
        const newRelY = newPivotBlock[1] * GRID_SIZE;

        return {
            blocks: rotatedBlocks,
            x: Math.round(pivotAbsX - newRelX),
            y: Math.round(pivotAbsY - newRelY)
        };
    }

    applyRotationLogic(sim) {
        this.blocks = sim.blocks;
        this.x = sim.x;
        this.y = sim.y;
        this.currentRotation = 0;
        this.targetRotation = 0;
        
        // å½¢çŠ¶ãŒå¤‰ã‚ã£ãŸã®ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å†ç”Ÿæˆ
        this.determinePivotBlock();
        this.prerender();
    }

    update() {
        let rotationFinished = false;

        if (this.isAnimating) {
            const diff = this.targetRotation - this.currentRotation;
            if (Math.abs(diff) < 0.01) {
                this.currentRotation = this.targetRotation;
                this.applyRotationLogic(this.pendingSimulation);
                this.isAnimating = false;
                this.pendingSimulation = null;
                rotationFinished = true;
            } else {
                this.currentRotation += diff * ROT_SPEED;
            }
        }

        if (this.animState === 'appearing') {
            this.animProgress += 0.04; 
            if (this.animProgress >= 1) {
                this.animProgress = 1;
                this.animState = 'idle';
            }
            const t = this.animProgress;
            const ease = 1 - Math.pow(1 - t, 3); 
            
            this.scale = 0.5 + 0.5 * ease; 
            this.opacity = ease; 

        } else if (this.animState === 'deleting') {
            this.animProgress += 0.08;
            this.opacity = 1 - this.animProgress;
            if (this.opacity <= 0) {
                this.opacity = 0;
                this.isDead = true; 
            }
        }

        return rotationFinished;
    }
    
    // --- ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‡¦ç† ---
    prerender() {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        this.blocks.forEach(([bx, by]) => {
            minX = Math.min(minX, bx); maxX = Math.max(maxX, bx);
            minY = Math.min(minY, by); maxY = Math.max(maxY, by);
        });
        
        const padding = 10; 
        const width = (maxX - minX + 1) * GRID_SIZE + padding * 2;
        const height = (maxY - minY + 1) * GRID_SIZE + padding * 2;

        this.cacheCanvas.width = width;
        this.cacheCanvas.height = height;
        
        this.cacheOffsetX = -minX * GRID_SIZE + padding;
        this.cacheOffsetY = -minY * GRID_SIZE + padding;
        
        const ctx = this.cacheCtx;
        ctx.clearRect(0, 0, width, height);
        
        ctx.save();
        ctx.translate(this.cacheOffsetX, this.cacheOffsetY);
        
        ctx.fillStyle = this.color;
        this._renderPath(ctx);
        ctx.fill();

        this._renderBonesAndDots(ctx);
        
        ctx.restore();
    }

    draw(ctx, colorOverride = null) {
        if (this.opacity <= 0 && this.animState !== 'appearing') return;

        ctx.save();
        
        let cx, cy;
        if (this.typeId === 5) {
            cx = this.x + 1.0 * GRID_SIZE;
            cy = this.y + 1.0 * GRID_SIZE;
        } else if (this.typeId === 0) {
             cx = this.x + 0.5 * GRID_SIZE;
             cy = this.y + 0.5 * GRID_SIZE;
        } else {
            const pivotBlock = this.blocks[this.pivotIndex];
            cx = this.x + (pivotBlock[0] + 0.5) * GRID_SIZE;
            cy = this.y + (pivotBlock[1] + 0.5) * GRID_SIZE;
        }

        ctx.translate(cx, cy);
        
        if (this.animState !== 'idle' || this.scale !== 1) {
            ctx.scale(this.scale, this.scale);
        }
        if (this.opacity !== 1) {
            ctx.globalAlpha = this.opacity;
        }

        ctx.rotate(this.currentRotation);
        
        ctx.translate(-cx, -cy);

        if (colorOverride) {
            ctx.save();
            ctx.translate(this.x, this.y); 
            ctx.fillStyle = colorOverride;
            this._renderPath(ctx);
            ctx.fill();
            this._renderBonesAndDots(ctx);
            ctx.restore();
        } else {
            ctx.drawImage(this.cacheCanvas, this.x - this.cacheOffsetX, this.y - this.cacheOffsetY);
        }

        ctx.restore();
    }
    
    _renderPath(ctx) {
        const has = (x, y) => this.has(x, y);
        ctx.beginPath();
        for (let [bx, by] of this.blocks) {
            const x = bx * GRID_SIZE; 
            const y = by * GRID_SIZE;
            const s = GRID_SIZE;
            const r = CORNER_RADIUS;

            const u = has(bx, by-1);
            const d = has(bx, by+1);
            const l = has(bx-1, by);
            const ri = has(bx+1, by);

            if (l || u) ctx.moveTo(x, y);
            else { ctx.moveTo(x, y+r); ctx.arcTo(x, y, x+r, y, r); }
            
            if (ri || u) ctx.lineTo(x+s, y);
            else { ctx.lineTo(x+s-r, y); ctx.arcTo(x+s, y, x+s, y+r, r); }
            
            if (ri || d) ctx.lineTo(x+s, y+s);
            else { ctx.lineTo(x+s, y+s-r); ctx.arcTo(x+s, y+s, x+s-r, y+s, r); }
            
            if (l || d) ctx.lineTo(x, y+s);
            else { ctx.lineTo(x+r, y+s); ctx.arcTo(x, y+s, x, y+s-r, r); }
        }
    }

    _renderBonesAndDots(ctx) {
        const centerOffset = GRID_SIZE / 2;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; 
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        for (let [bx, by] of this.blocks) {
            const cx = bx * GRID_SIZE + centerOffset;
            const cy = by * GRID_SIZE + centerOffset;
            if (this.has(bx + 1, by)) {
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + GRID_SIZE, cy);
            }
            if (this.has(bx, by + 1)) {
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx, cy + GRID_SIZE);
            }
        }
        ctx.stroke();
        ctx.fillStyle = '#ffffff'; 
        for (let [bx, by] of this.blocks) {
            const cx = bx * GRID_SIZE + centerOffset;
            const cy = by * GRID_SIZE + centerOffset;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    has(x, y) {
        return this.blocks.some(b => b[0]===x && b[1]===y);
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.pieces = [];
        this.dragTarget = null;
        this.dragOffset = {x:0, y:0};
        
        this.glowingCells = new Set(); 
        this.glowingClusterPieces = []; 

        this.zukan = new Zukan();
        this.sound = new SoundSystem(); 

        this.tetrominoBag = [];
        this.smallPieceBag = []; // å°ã•ãªãƒŸãƒç”¨ãƒãƒƒã‚°

        this.monominoStock = 0;
        this.maxMonominoStock = 9; // ã‚¹ãƒˆãƒƒã‚¯ä¸Šé™ã‚’9ã«å¤‰æ›´

        this.dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.initInput();
        
        this.initHelp();

        setInterval(() => this.updateClock(), 1000);
        this.updateClock(); 

        document.getElementById('se-toggle').addEventListener('change', (e) => {
            this.sound.toggleMute(!e.target.checked);
        });

        this.loadGame();

        requestAnimationFrame((t) => this.loop(t));
    }

    saveGame() {
        const validPieces = this.pieces
            .filter(p => p.animState !== 'deleting')
            .map(p => p.serialize());

        const data = {
            pieces: validPieces,
            stock: this.monominoStock
        };
        localStorage.setItem('octomino_game_state', JSON.stringify(data));
    }

    loadGame() {
        const json = localStorage.getItem('octomino_game_state');
        if (json) {
            try {
                const data = JSON.parse(json);
                this.monominoStock = data.stock || 0;
                if (Array.isArray(data.pieces)) {
                    this.pieces = data.pieces.map(d => Polyomino.deserialize(d));
                }
                this.updateMonominoUI();
                this.checkClusters();
            } catch (e) {
                console.error("Save data corrupted", e);
            }
        }
    }
    
    // --- UI/åˆæœŸåŒ– ---
    initHelp() {
        const modal = document.getElementById('help-modal');
        const helpBtn = document.getElementById('help-menu-btn');
        const close = document.getElementById('help-close');

        const open = () => {
            modal.classList.add('active');
            document.getElementById('side-menu').classList.remove('active');
        };
        const closeFunc = () => modal.classList.remove('active');

        helpBtn.onclick = open;
        close.onclick = closeFunc;

        if (this.zukan.collected.size === 0) {
            open();
        }
    }

    updateClock() {
        const now = new Date();
        const h = String(now.getHours()).padStart(2, '0');
        const m = String(now.getMinutes()).padStart(2, '0');
        document.getElementById('clock-display').textContent = `${h}:${m}`;
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;

        this.dpr = window.devicePixelRatio || 1;
        this.canvas.width = this.width * this.dpr;
        this.canvas.height = this.height * this.dpr;

        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';

        this.ctx.scale(this.dpr, this.dpr);
    }

    // --- ãƒ¢ãƒãƒŸãƒå¬å–šã‚·ã‚¹ãƒ†ãƒ  ---
    addMonominoStock(amount) {
        this.monominoStock = Math.min(this.monominoStock + amount, this.maxMonominoStock);
        this.updateMonominoUI();
    }

    consumeMonominoStock() {
        if (this.monominoStock > 0) {
            this.monominoStock--;
            this.updateMonominoUI();
            return true;
        }
        return false;
    }

    updateMonominoUI() {
        const btn = document.getElementById('monomino-btn');
        const label = document.getElementById('monomino-stock');
        label.textContent = `${this.monominoStock}`;
        btn.disabled = (this.monominoStock <= 0);
    }

    spawnMonomino() {
        if (!this.consumeMonominoStock()) return;

        this.sound.init();
        this.sound.playSpawn();

        const cx = this.width / 2;
        const cy = this.height / 2;
        const gridX = Math.floor(cx / GRID_SIZE);
        const gridY = Math.floor(cy / GRID_SIZE);

        const offsets = [];
        const radius = 20; 
        for(let r=0; r<=radius; r++) {
            for(let x=-r; x<=r; x++) {
                for(let y=-r; y<=r; y++) {
                    if (Math.abs(x) === r || Math.abs(y) === r) {
                        offsets.push({x, y});
                    }
                }
            }
        }

        const typeId = 0; 
        const s = SHAPES[typeId];
        const c = SHAPE_COLORS[typeId];

        for(let off of offsets) {
            const tx = (gridX + off.x) * GRID_SIZE; 
            const ty = (gridY + off.y) * GRID_SIZE;
            
            if (tx < 0 || tx > this.width - GRID_SIZE || ty < 0 || ty > this.height - GRID_SIZE) continue;

            const p = new Polyomino(s, tx, ty, c, typeId);
            
            const checkState = { blocks: p.blocks, x: p.x, y: p.y };
            if (this.isValidState(checkState, p)) {
                p.startAppearAnimation();
                this.pieces.push(p); 
                break;
            }
        }
        this.checkClusters();
        this.saveGame(); 
    }

    spawnBlockSet(cx, cy) {
        this.sound.init();
        this.sound.playSpawn(); 

        const gridX = Math.floor(cx / GRID_SIZE);
        const gridY = Math.floor(cy / GRID_SIZE);

        // --- ãƒ†ãƒˆãƒ­ãƒŸãƒã®æŠ½é¸ (7-Bag) ---
        if (this.tetrominoBag.length === 0) {
            this.tetrominoBag = [4, 5, 6, 7, 8, 9, 10];
            for (let i = this.tetrominoBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.tetrominoBag[i], this.tetrominoBag[j]] = [this.tetrominoBag[j], this.tetrominoBag[i]];
            }
        }
        const nextTetrominoId = this.tetrominoBag.pop();

        // --- ã‚¹ãƒ¢ãƒ¼ãƒ«ãƒŸãƒã®æŠ½é¸ (3-Bag: Domino, Tromino I, Tromino L) ---
        if (this.smallPieceBag.length === 0) {
            this.smallPieceBag = [1, 2, 3]; // 1:Domino, 2:Tromino-I, 3:Tromino-L
            for (let i = this.smallPieceBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.smallPieceBag[i], this.smallPieceBag[j]] = [this.smallPieceBag[j], this.smallPieceBag[i]];
            }
        }
        const nextSmallId = this.smallPieceBag.pop();

        // 2å€‹ç”Ÿæˆ (Small x1 + Tetromino x1)
        const typesToSpawn = [nextSmallId, nextTetrominoId];
        typesToSpawn.sort(() => Math.random() - 0.5);

        const offsets = [];
        const radius = 15; 
        for(let r=0; r<=radius; r++) {
            for(let x=-r; x<=r; x++) {
                for(let y=-r; y<=r; y++) {
                    if (Math.abs(x) === r || Math.abs(y) === r) {
                        offsets.push({x, y});
                    }
                }
            }
        }

        for (let typeId of typesToSpawn) {
            let s = JSON.parse(JSON.stringify(SHAPES[typeId]));
            const c = SHAPE_COLORS[typeId];
            
            // â˜…è¿½åŠ : ãƒ©ãƒ³ãƒ€ãƒ å›è»¢ (0ï½3å›)
            const rot = Math.floor(Math.random() * 4);
            s = rotateShapePoints(s, rot);

            let placed = false;
            for(let off of offsets) {
                const tx = (gridX + off.x) * GRID_SIZE; 
                const ty = (gridY + off.y) * GRID_SIZE;
                
                if (tx < 0 || tx > this.width - GRID_SIZE || ty < 0 || ty > this.height - GRID_SIZE) continue;

                const p = new Polyomino(s, tx, ty, c, typeId);
                
                const checkState = { blocks: p.blocks, x: p.x, y: p.y };
                if (this.isValidState(checkState, p)) {
                    p.startAppearAnimation();
                    this.pieces.push(p); 
                    placed = true;
                    break;
                }
            }
        }
        this.checkClusters();
        this.saveGame(); 
    }

    clearAllPieces() {
        showCustomConfirm("ç›¤ä¸Šã®ãƒŸãƒã‚’å…¨ã¦å‰Šé™¤ã—ã¾ã™", () => {
            this.pieces = [];
            this.checkClusters();
            this.saveGame(); 
        });
    }

    getPieceAt(mx, my) {
        for (let i = this.pieces.length - 1; i >= 0; i--) {
            const p = this.pieces[i];
            if (p.animState === 'deleting' || p.scale < 0.5) continue;

            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            p.blocks.forEach(([bx,by])=>{minX=Math.min(minX,bx); maxX=Math.max(maxX,bx); minY=Math.min(minY,by); maxY=Math.max(maxY,by);});
            
            const px = p.x; const py = p.y;
            if (mx >= px + minX*GRID_SIZE && mx < px + (maxX+1)*GRID_SIZE &&
                my >= py + minY*GRID_SIZE && my < py + (maxY+1)*GRID_SIZE) {
                return p;
            }
        }
        return null;
    }

    isValidState(state, ignorePiece) {
        const snapX = Math.round(state.x / GRID_SIZE) * GRID_SIZE;
        const snapY = Math.round(state.y / GRID_SIZE) * GRID_SIZE;
        
        let minY = Infinity;
        state.blocks.forEach(b => minY = Math.min(minY, b[1]));
        
        for (let [bx, by] of state.blocks) {
            const absX = snapX + bx * GRID_SIZE;
            const absY = snapY + by * GRID_SIZE;

            if (absX < 0 || absX + GRID_SIZE > this.width || absY < 0 || absY + GRID_SIZE > this.height) return false;

            for (let other of this.pieces) {
                if (other === ignorePiece) continue;
                if (other.animState === 'deleting') continue;

                const oX = Math.round(other.x / GRID_SIZE) * GRID_SIZE;
                const oY = Math.round(other.y / GRID_SIZE) * GRID_SIZE;
                
                for (let [obx, oby] of other.blocks) {
                    const oAbsX = oX + obx * GRID_SIZE;
                    const oAbsY = oY + oby * GRID_SIZE;
                    if (Math.abs(absX - oAbsX) < 10 && Math.abs(absY - oAbsY) < 10) return false;
                }
            }
        }
        return true;
    }

    checkClusters() {
        const placed = this.pieces.filter(p => !p.isDragging && p.animState !== 'deleting');
        
        this.glowingCells.clear();
        this.glowingClusterPieces = []; 

        const gridMap = new Map();
        placed.forEach(p => {
            const gridX = Math.round(p.x / GRID_SIZE);
            const gridY = Math.round(p.y / GRID_SIZE);
            p.blocks.forEach(([bx, by]) => {
                const key = `${gridX + bx},${gridY + by}`;
                gridMap.set(key, p);
            });
        });

        const visited = new Set();

        for (let p of placed) {
            if (visited.has(p)) continue;

            const cluster = [p];
            const queue = [p];
            visited.add(p);
            let totalBlocks = 0;

            while(queue.length > 0) {
                const curr = queue.shift();
                totalBlocks += curr.blocks.length;

                const cx = Math.round(curr.x / GRID_SIZE);
                const cy = Math.round(curr.y / GRID_SIZE);

                curr.blocks.forEach(([bx, by]) => {
                    const gx = cx + bx;
                    const gy = cy + by;
                    const neighbors = [
                        `${gx+1},${gy}`, `${gx-1},${gy}`, 
                        `${gx},${gy+1}`, `${gx},${gy-1}`
                    ];
                    
                    neighbors.forEach(key => {
                        if (gridMap.has(key)) {
                            const neighborPiece = gridMap.get(key);
                            if (!visited.has(neighborPiece)) {
                                visited.add(neighborPiece);
                                cluster.push(neighborPiece);
                                queue.push(neighborPiece);
                            }
                        }
                    });
                });
            }

            // 8å€‹ã¾ãŸã¯9å€‹ã®å¡Šãªã‚‰å…‰ã‚‰ã›ã‚‹
            if (totalBlocks === 8 || totalBlocks === 9) {
                cluster.forEach(cp => {
                    const cx = Math.round(cp.x / GRID_SIZE);
                    const cy = Math.round(cp.y / GRID_SIZE);
                    cp.blocks.forEach(([bx, by]) => {
                        this.glowingCells.add(`${cx + bx},${cy + by}`);
                    });
                });
                this.glowingClusterPieces.push(cluster);
            }
        }
    }

    tryRegisterOctomino(clickedPiece) {
        const targetCluster = this.glowingClusterPieces.find(cluster => cluster.includes(clickedPiece));
        
        if (!targetCluster) return;

        const blocks = [];
        const consumedTypeIds = [];

        targetCluster.forEach(p => {
            const gx = Math.round(p.x / GRID_SIZE);
            const gy = Math.round(p.y / GRID_SIZE);
            p.blocks.forEach(([bx, by]) => {
                blocks.push({x: gx+bx, y: gy+by});
            });
            consumedTypeIds.push(p.typeId);
        });

        const result = this.zukan.register(blocks, consumedTypeIds);
        const num = result.index + 1;

        if (result.index === -1) {
            this.showToast("Unknown Shape", 'existing');
        } else {
            const isOctomino = (result.length === 8);
            const typeName = isOctomino ? "ã‚ªã‚¯ãƒˆãƒŸãƒ" : "ãƒãƒãƒŸãƒ";
            
            if (result.isNew) {
                const toastType = isOctomino ? 'new-octo' : 'new-nono';
                this.showToast(`${typeName}#${num}ã‚’ç™»éŒ²ã—ã¾ã—ãŸ`, toastType);
                this.sound.playNewDiscovery(); 
            } else {
                this.showToast(`${typeName}#${num}ã¯ã™ã§ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™`, 'existing');
                this.sound.playAlreadyKnown(); 
            }
            // ä¾›çµ¦ã¯1ã¤
            this.addMonominoStock(1);
        }

        targetCluster.forEach(p => {
            p.startDeleteAnimation();
        });
        
        this.checkClusters();
        this.saveGame(); 
    }

    showToast(msg, type) {
        const toast = document.getElementById('toast');
        if (this.toastTimer) clearTimeout(this.toastTimer);
        
        toast.className = '';
        void toast.offsetWidth; // ãƒªãƒ•ãƒ­ãƒ¼å¼·åˆ¶

        toast.textContent = msg;
        // type: 'existing', 'new-octo', 'new-nono'
        toast.className = `show ${type}`;
        
        this.toastTimer = setTimeout(() => {
            toast.classList.remove('show');
        }, 2000);
    }

    tryRotate(piece, dir) {
        if (piece.isAnimating || piece.isDragging || piece.animState !== 'idle') return;
        
        this.sound.init();

        const sim = piece.simulateRotation(dir);
        
        const checkState = {
            blocks: sim.blocks,
            x: sim.x,
            y: sim.y
        };

        if (this.isValidState(checkState, piece)) {
            piece.pendingSimulation = sim;
            piece.targetRotation += dir * (Math.PI / 2);
            piece.isAnimating = true;
            this.sound.playRotate(); 
        }
    }

    initInput() {
        const ham = document.getElementById('hamburger-btn');
        const menu = document.getElementById('side-menu');
        ham.addEventListener('click', () => {
            menu.classList.toggle('active');
        });
        
        document.getElementById('clear-menu-btn').addEventListener('click', () => {
            this.clearAllPieces();
            menu.classList.remove('active');
        });
        
        document.getElementById('zukan-menu-btn').addEventListener('click', () => {
            this.zukan.openZukan();
            menu.classList.remove('active');
        });

        document.getElementById('monomino-btn').addEventListener('click', () => {
            this.spawnMonomino();
        });

        this.canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const p = this.getPieceAt(e.clientX, e.clientY);
            if (p) {
                this.tryRegisterOctomino(p);
            }
        });

        this.canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const p = this.dragTarget || this.getPieceAt(e.clientX, e.clientY);
            if (p) {
                const dir = e.deltaY > 0 ? 1 : -1;
                this.tryRotate(p, dir);
            }
        }, { passive: false });

        this.canvas.addEventListener('dblclick', e => {
            e.preventDefault();
            if (!this.getPieceAt(e.clientX, e.clientY)) {
                this.spawnBlockSet(e.clientX, e.clientY);
            }
        });

        this.canvas.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            this.sound.init();

            const p = this.getPieceAt(e.clientX, e.clientY);
            if (p && !p.isAnimating && p.animState === 'idle') {
                this.dragTarget = p;
                this.dragOffset = {x: e.clientX - p.x, y: e.clientY - p.y};
                p.isDragging = true;
                p.prevX = p.x; p.prevY = p.y;
                
                this.pieces.push(this.pieces.splice(this.pieces.indexOf(p), 1)[0]);
                document.body.classList.add('cursor-grabbing');

                this.checkClusters();
            } else {
                if(menu.classList.contains('active')) {
                    menu.classList.remove('active');
                }
            }
        });

        this.canvas.addEventListener('mousemove', e => {
            const hover = this.getPieceAt(e.clientX, e.clientY);
            this.canvas.className = hover ? 'cursor-grab' : '';

            if (this.dragTarget) {
                this.dragTarget.x = e.clientX - this.dragOffset.x;
                this.dragTarget.y = e.clientY - this.dragOffset.y;
            }
        });

        this.canvas.addEventListener('mouseup', e => {
            if (e.button === 0 && this.dragTarget) {
                this.dropPiece(this.dragTarget);
                
                this.dragTarget.isDragging = false; 
                this.checkClusters();
                
                this.dragTarget = null;
                document.body.classList.remove('cursor-grabbing');
            }
        });
    }

    dropPiece(p) {
        const snapX = Math.round(p.x / GRID_SIZE) * GRID_SIZE;
        const snapY = Math.round(p.y / GRID_SIZE) * GRID_SIZE;

        const checkState = { blocks: p.blocks, x: snapX, y: snapY };
        if (this.isValidState(checkState, p)) {
            if (p.x !== snapX || p.y !== snapY) {
                this.sound.playDrop(); 
            }
            p.x = snapX;
            p.y = snapY;
        } else {
            p.x = p.prevX;
            p.y = p.prevY;
        }
        this.saveGame(); // â˜…ä¿å­˜
    }

    drawBackgrounds() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = BG_COLOR_GRID_AREA;
        this.ctx.fillRect(0, 0, this.width, this.height);
    }

    drawGlowingLinesEffect() {
        if (this.glowingCells.size === 0) return;

        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; 
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        this.ctx.lineWidth = 4;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
        this.ctx.shadowBlur = 10; 

        this.ctx.beginPath();
        for (let key of this.glowingCells) {
            const [gx, gy] = key.split(',').map(Number);
            const cx = gx * GRID_SIZE + GRID_SIZE / 2;
            const cy = gy * GRID_SIZE + GRID_SIZE / 2;

            if (this.glowingCells.has(`${gx+1},${gy}`)) {
                this.ctx.moveTo(cx, cy);
                this.ctx.lineTo(cx + GRID_SIZE, cy);
            }
            if (this.glowingCells.has(`${gx},${gy+1}`)) {
                this.ctx.moveTo(cx, cy);
                this.ctx.lineTo(cx, cy + GRID_SIZE);
            }
        }
        this.ctx.stroke();
        
        for (let key of this.glowingCells) {
            const [gx, gy] = key.split(',').map(Number);
            const cx = gx * GRID_SIZE + GRID_SIZE / 2;
            const cy = gy * GRID_SIZE + GRID_SIZE / 2;
            this.ctx.beginPath();
            this.ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.restore();
    }

    drawGridDots() {
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; 

        for (let x = 0; x <= this.width; x += GRID_SIZE) {
            for (let y = 0; y <= this.height; y += GRID_SIZE) {
                const cx = x + GRID_SIZE / 2;
                const cy = y + GRID_SIZE / 2;
                if (cx > this.width || cy > this.height) continue;

                this.ctx.beginPath();
                this.ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    loop(timestamp) {
        this.drawBackgrounds();
        this.drawGridDots();

        // å‰Šé™¤å®Œäº†ã—ãŸãƒ”ãƒ¼ã‚¹ã‚’é™¤å»
        const prevCount = this.pieces.length;
        this.pieces = this.pieces.filter(p => !p.isDead);
        const currentCount = this.pieces.length;
        
        if (prevCount !== currentCount) {
            this.saveGame(); // â˜…å‰Šé™¤å®Œäº†æ™‚ã«ä¿å­˜
        }

        let needClusterUpdate = false;
        let anyRotationFinished = false;

        for (let p of this.pieces) {
            const rotationFinished = p.update();
            if (rotationFinished) {
                needClusterUpdate = true;
                anyRotationFinished = true;
            }
            
            let colorOverride = null;
            if (p.isDragging) {
                const snapX = Math.round(p.x / GRID_SIZE) * GRID_SIZE;
                const snapY = Math.round(p.y / GRID_SIZE) * GRID_SIZE;
                if (!this.isValidState({blocks: p.blocks, x: snapX, y: snapY}, p)) {
                    colorOverride = '#90A4AE'; 
                }
            }
            p.draw(this.ctx, colorOverride);
        }

        if (needClusterUpdate) {
            this.checkClusters();
        }
        
        if (anyRotationFinished) {
            this.saveGame(); // â˜…å›è»¢çµ‚äº†æ™‚ã«ä¿å­˜
        }

        this.drawGlowingLinesEffect();

        requestAnimationFrame((t) => this.loop(t));
    }
}

window.onload = () => new Game();
</script>
</body>
</html>
